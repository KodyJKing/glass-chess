{"version":3,"file":"api\\search.pack.js","sources":["webpack:///webpack/bootstrap","webpack:///./lib/engine/Color.js","webpack:///./lib/engine/Engine.js","webpack:///./lib/engine/Move.js","webpack:///./lib/engine/Piece.js","webpack:///./lib/engine/Position.js","webpack:///./lib/engine/Type.js","webpack:///./lib/engine/bitfield.js","webpack:///./lib/engine/common.js","webpack:///./lib/engine/pieceValues.js","webpack:///./lib/engine/search.js","webpack:///./lib/www/api/search.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/www/api/search.js\");\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Color;\r\n(function (Color) {\r\n    Color[Color[\"White\"] = 0] = \"White\";\r\n    Color[Color[\"Black\"] = 1] = \"Black\";\r\n})(Color = exports.Color || (exports.Color = {}));\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Type_1 = require(\"./Type\");\r\nconst Color_1 = require(\"./Color\");\r\nconst Piece_1 = __importDefault(require(\"./Piece\"));\r\nconst Position_1 = __importDefault(require(\"./Position\"));\r\nconst Move_1 = __importDefault(require(\"./Move\"));\r\nconst common_1 = require(\"./common\");\r\nconst pieceValues_1 = __importDefault(require(\"./pieceValues\"));\r\nconst Pos = Position_1.default.create;\r\nconst posX = Position_1.default.get.x;\r\nconst posY = Position_1.default.get.y;\r\nconst EMPTY = Piece_1.default.create(0, 0, 0);\r\nvar Ternary;\r\n(function (Ternary) {\r\n    Ternary[Ternary[\"always\"] = 0] = \"always\";\r\n    Ternary[Ternary[\"never\"] = 1] = \"never\";\r\n    Ternary[Ternary[\"either\"] = 2] = \"either\";\r\n})(Ternary || (Ternary = {}));\r\nclass Engine {\r\n    constructor() {\r\n        try {\r\n            window.engine = this;\r\n        }\r\n        catch (e) { }\r\n        this.clear();\r\n    }\r\n    clear() {\r\n        this.pieces = new Uint8Array(64);\r\n        this.ids = new Uint8Array(64);\r\n        for (let i = 0; i < 64; i++)\r\n            this.ids[i] = i;\r\n        this.turn = Color_1.Color.White;\r\n        this.netMaterialValue = 0;\r\n        this.history = [];\r\n    }\r\n    standardSetup() {\r\n        for (let x = 0; x < 8; x++) {\r\n            let type = Piece_1.default.get.type(common_1.charToPiece(\"rnbqkbnr\"[x]));\r\n            this.pieces[Pos(x, 0)] = Piece_1.default.create(type, Color_1.Color.Black, 0);\r\n            this.pieces[Pos(x, 1)] = Piece_1.default.create(Type_1.Type.Pawn, Color_1.Color.Black, 0);\r\n            this.pieces[Pos(x, 7)] = Piece_1.default.create(type, Color_1.Color.White, 0);\r\n            this.pieces[Pos(x, 6)] = Piece_1.default.create(Type_1.Type.Pawn, Color_1.Color.White, 0);\r\n        }\r\n        return this;\r\n    }\r\n    static parseBoard(board) {\r\n        let rows = board.split(\"\\n\")\r\n            .filter((row) => row.length > 0) // Remove empty lines.\r\n            .map((row) => row.replace(/ /g, \"\") // Remove whitespace.\r\n            .split(\"\") // Convert to char array.\r\n            .map(common_1.charToPiece));\r\n        let engine = new Engine();\r\n        for (let y = 0; y < 8; y++) {\r\n            for (let x = 0; x < 8; x++) {\r\n                engine.pieces[Pos(x, y)] = rows[y][x];\r\n            }\r\n        }\r\n        return engine;\r\n    }\r\n    prettyString(moves) {\r\n        let positions = moves ? moves.map((move) => Move_1.default.get.to(move)) : [];\r\n        let result = [];\r\n        for (let y = 0; y < 8; y++) {\r\n            let row = [];\r\n            for (let x = 0; x < 8; x++) {\r\n                let char;\r\n                if (positions.indexOf(Position_1.default.create(x, y)) > -1)\r\n                    char = \"#\";\r\n                else\r\n                    char = common_1.pieceToChar(this.pieces[Pos(x, y)]);\r\n                row.push(char + \" \");\r\n            }\r\n            result.push(row.join(\"\"));\r\n        }\r\n        return result.join(\"\\n\");\r\n    }\r\n    static compareBoards(a, b) {\r\n        let format = (x) => (x.split(\"\\n\")\r\n            .map((x) => x.trim())\r\n            .filter((x) => x.length > 0)).join(\"\\n\");\r\n        return format(a) === format(b);\r\n    }\r\n    positionString() {\r\n        let parts = new Array(24);\r\n        let i = 0;\r\n        for (let y = 0; y < 8; y++)\r\n            for (let x = 0; x < 8; x += 3)\r\n                parts[i++] = String.fromCharCode((this.pieces[Pos(x, y)] << 10) |\r\n                    (this.pieces[Pos(x + 1, y)] << 5) |\r\n                    (this.pieces[Pos(x + 2, y)] || 0));\r\n        return parts.join(\"\");\r\n    }\r\n    toString() {\r\n        let parts = new Array();\r\n        for (let move of this.history)\r\n            parts.push(String.fromCharCode(Move_1.default.set.firstMove(Move_1.default.set.captured(move, 0), 0)));\r\n        return parts.join(\"\");\r\n    }\r\n    static fromString(movesString) {\r\n        let engine = new Engine();\r\n        engine.standardSetup();\r\n        for (let i = 0; i < movesString.length; i++)\r\n            engine.doMove(movesString.charCodeAt(i));\r\n        return engine;\r\n    }\r\n    static fromHistory(moves) {\r\n        let engine = new Engine();\r\n        engine.standardSetup();\r\n        for (let move of moves)\r\n            engine.doMove(move);\r\n        return engine;\r\n    }\r\n    // Move Generation\r\n    slide(from, dx, dy, max, color, selfCaptures, captures, moves) {\r\n        let count = 0;\r\n        let x = posX(from);\r\n        let y = posY(from);\r\n        for (let i = 1; i <= max; i++) {\r\n            x += dx;\r\n            y += dy;\r\n            if (x < 0 || x >= 8 || y < 0 || y >= 8)\r\n                break;\r\n            let to = Pos(x, y);\r\n            let obstacle = this.pieces[to];\r\n            let move = Move_1.default.create(to, from, obstacle, 0);\r\n            if (Piece_1.default.get.type(obstacle) !== Type_1.Type.Empty) {\r\n                if (captures !== Ternary.never && Piece_1.default.get.color(obstacle) !== color) {\r\n                    moves.push(move);\r\n                    return ++count;\r\n                }\r\n                break;\r\n            }\r\n            else if (captures !== Ternary.always) {\r\n                moves.push(move);\r\n                ++count;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    slideCardinals(pos, max, color, selfCaptures, captures, moves) {\r\n        this.slide(pos, 1, 0, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, -1, 0, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, 0, -1, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, 0, 1, max, color, selfCaptures, captures, moves);\r\n    }\r\n    slideDiagonals(pos, max, color, selfCaptures, captures, moves) {\r\n        this.slide(pos, 1, 1, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, -1, 1, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, 1, -1, max, color, selfCaptures, captures, moves);\r\n        this.slide(pos, -1, -1, max, color, selfCaptures, captures, moves);\r\n    }\r\n    generateMoves(pos, type, color, moved, selfCaptures, captures) {\r\n        let moves = [];\r\n        switch (type) {\r\n            case Type_1.Type.Pawn: {\r\n                let dy = color == Color_1.Color.White ? -1 : 1;\r\n                this.slide(pos, 0, dy, moved ? 1 : 2, color, selfCaptures, Ternary.never, moves);\r\n                this.slide(pos, -1, dy, 1, color, selfCaptures, Ternary.always, moves);\r\n                this.slide(pos, 1, dy, 1, color, selfCaptures, Ternary.always, moves);\r\n                if ((Position_1.default.get.y(pos) == 6 && color == Color_1.Color.Black) ||\r\n                    (Position_1.default.get.y(pos) == 1 && color == Color_1.Color.White)) {\r\n                    for (let i = 0; i < moves.length; i++)\r\n                        moves[i] = Move_1.default.set.promotion(moves[i], 1);\r\n                }\r\n                break;\r\n            }\r\n            case Type_1.Type.Knight: {\r\n                // QI, +x, +y\r\n                this.slide(pos, 2, 1, 1, color, selfCaptures, captures, moves);\r\n                this.slide(pos, 1, 2, 1, color, selfCaptures, captures, moves);\r\n                // QII, -x, +y\r\n                this.slide(pos, -2, 1, 1, color, selfCaptures, captures, moves);\r\n                this.slide(pos, -1, 2, 1, color, selfCaptures, captures, moves);\r\n                // QIII, -x, -y\r\n                this.slide(pos, -2, -1, 1, color, selfCaptures, captures, moves);\r\n                this.slide(pos, -1, -2, 1, color, selfCaptures, captures, moves);\r\n                // QIV, +x, -y\r\n                this.slide(pos, 2, -1, 1, color, selfCaptures, captures, moves);\r\n                this.slide(pos, 1, -2, 1, color, selfCaptures, captures, moves);\r\n                break;\r\n            }\r\n            case Type_1.Type.Bishop: {\r\n                this.slideDiagonals(pos, 7, color, selfCaptures, captures, moves);\r\n                break;\r\n            }\r\n            case Type_1.Type.Rook: {\r\n                this.slideCardinals(pos, 7, color, selfCaptures, captures, moves);\r\n                break;\r\n            }\r\n            case Type_1.Type.Queen: {\r\n                this.slideDiagonals(pos, 7, color, selfCaptures, captures, moves);\r\n                this.slideCardinals(pos, 7, color, selfCaptures, captures, moves);\r\n                break;\r\n            }\r\n            case Type_1.Type.King: {\r\n                this.slideDiagonals(pos, 1, color, selfCaptures, captures, moves);\r\n                this.slideCardinals(pos, 1, color, selfCaptures, captures, moves);\r\n                if (!moved) {\r\n                    if (this.canCastle(pos, color, -1))\r\n                        moves.push(Move_1.default.create(Pos(2, posY(pos)), pos, 0, 1));\r\n                    if (this.canCastle(pos, color, 1))\r\n                        moves.push(Move_1.default.create(Pos(6, posY(pos)), pos, 0, 1));\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return moves;\r\n    }\r\n    canCastle(pos, color, dx) {\r\n        return this.rookVisible(pos, color, dx) && !this.passesThroughCheck(pos, color, dx);\r\n    }\r\n    rookVisible(pos, color, dx) {\r\n        let x = posX(pos);\r\n        let y = posY(pos);\r\n        while (x >= 0 && x <= 7) {\r\n            x += dx;\r\n            let piece = this.pieces[Pos(x, y)];\r\n            let type = Piece_1.default.get.type(piece);\r\n            if (type != Type_1.Type.Empty)\r\n                return type === Type_1.Type.Rook && !Piece_1.default.get.moved(piece) && Piece_1.default.get.color(piece) === color;\r\n        }\r\n        return false;\r\n    }\r\n    passesThroughCheck(pos, color, dx) {\r\n        let x = posX(pos);\r\n        let y = posY(pos);\r\n        for (let i = 0; i < 2; i++)\r\n            if (!this.isSafe(Pos(x + i * dx, y), color))\r\n                return true;\r\n        return false;\r\n    }\r\n    tryCastle(to, from, undo) {\r\n        let dx = posX(to) - posX(from);\r\n        if (Math.abs(dx) < 2)\r\n            return;\r\n        let y = posY(to);\r\n        let rookFrom = Pos(dx > 0 ? 7 : 0, y);\r\n        let rookTo = Pos(posX(to) - Math.sign(dx), y);\r\n        if (undo) {\r\n            let rook = this.pieces[rookTo];\r\n            this.pieces[rookFrom] = Piece_1.default.set.moved(rook, 0);\r\n            this.pieces[rookTo] = EMPTY;\r\n            this.swapIds(rookFrom, rookTo);\r\n        }\r\n        else {\r\n            let rook = this.pieces[rookFrom];\r\n            this.pieces[rookFrom] = EMPTY;\r\n            this.pieces[rookTo] = Piece_1.default.set.moved(rook, 1);\r\n            this.swapIds(rookFrom, rookTo);\r\n        }\r\n    }\r\n    setPiece(pos, piece) {\r\n        let captured = this.pieces[pos];\r\n        this.netMaterialValue -= pieceValues_1.default[Piece_1.default.get.type(captured)] * (Piece_1.default.get.color(captured) == Color_1.Color.White ? 1 : -1);\r\n        this.netMaterialValue += pieceValues_1.default[Piece_1.default.get.type(piece)] * (Piece_1.default.get.color(piece) == Color_1.Color.White ? 1 : -1);\r\n        this.pieces[pos] = piece;\r\n    }\r\n    swapIds(p, q) {\r\n        let tmp = this.ids[p];\r\n        this.ids[p] = this.ids[q];\r\n        this.ids[q] = tmp;\r\n    }\r\n    doMove(move) {\r\n        this.history.push(move);\r\n        let from = Move_1.default.get.from(move);\r\n        let to = Move_1.default.get.to(move);\r\n        let piece = Piece_1.default.set.moved(this.pieces[from], 1);\r\n        if (Move_1.default.get.promotion(move))\r\n            piece = Piece_1.default.set.type(piece, Type_1.Type.Queen);\r\n        this.setPiece(from, EMPTY);\r\n        this.setPiece(to, piece);\r\n        this.turn = (this.turn + 1) % 2;\r\n        this.swapIds(to, from);\r\n        if (Piece_1.default.get.type(piece) === Type_1.Type.King)\r\n            this.tryCastle(to, from, false);\r\n    }\r\n    undoMove() {\r\n        let move = this.history.pop();\r\n        let from = Move_1.default.get.from(move);\r\n        let to = Move_1.default.get.to(move);\r\n        let piece = Piece_1.default.set.moved(this.pieces[to], Move_1.default.get.firstMove(move) ? 0 : 1);\r\n        if (Move_1.default.get.promotion(move))\r\n            piece = Piece_1.default.set.type(piece, Type_1.Type.Pawn);\r\n        this.setPiece(from, piece);\r\n        this.setPiece(to, Move_1.default.get.captured(move));\r\n        this.turn = (this.turn + 1) % 2;\r\n        this.swapIds(to, from);\r\n        if (Piece_1.default.get.type(piece) === Type_1.Type.King)\r\n            this.tryCastle(to, from, true);\r\n    }\r\n    generateMovesAt(pos, selfCaptures = false) {\r\n        let piece = this.pieces[pos];\r\n        let moves = this.generateMoves(pos, Piece_1.default.get.type(piece), Piece_1.default.get.color(piece), Piece_1.default.get.moved(piece), selfCaptures, Ternary.either);\r\n        if (!Piece_1.default.get.moved(piece))\r\n            for (let i = 0; i < moves.length; i++)\r\n                moves[i] = Move_1.default.set.firstMove(moves[i], 1);\r\n        return moves;\r\n    }\r\n    generateSafeMovesAt(pos) {\r\n        let piece = this.pieces[pos];\r\n        let color = Piece_1.default.get.color(piece);\r\n        return this.filterByKingSafety(color, this.generateMovesAt(pos));\r\n    }\r\n    // This can be slow because it is only used by filterByKingSafetly.\r\n    kingPos(turn) {\r\n        for (let i = 0; i < 64; i++) {\r\n            let p = this.pieces[i];\r\n            if (Piece_1.default.get.type(p) === Type_1.Type.King && Piece_1.default.get.color(p) === turn)\r\n                return i;\r\n        }\r\n        return null;\r\n        // throw new Error(`Missing ${turn} king.`)\r\n    }\r\n    // This can be slow because it's not used in the search algorithm.\r\n    // Because of the piece value of the king, this check would be redundant.\r\n    filterByKingSafety(turn, moves) {\r\n        let result = [];\r\n        for (let move of moves) {\r\n            this.doMove(move);\r\n            let kingPos = this.kingPos(turn);\r\n            if (kingPos == null || this.isSafe(kingPos, turn))\r\n                result.push(move);\r\n            this.undoMove();\r\n        }\r\n        return result;\r\n    }\r\n    // Capturing moves are direction reversible so it's OK to scan from the friendly piece to the enemy pieces.\r\n    // If we do this for each type, we can be sure no pieces threaten our piece.\r\n    // If we can 'capture' them, they can capture us.\r\n    isSafe(pos, color) {\r\n        for (let type = Type_1.Type.Pawn; type <= Type_1.Type.King; type++) {\r\n            let moves = this.generateMoves(pos, type, color, 1, false, Ternary.always);\r\n            for (let move of moves) {\r\n                let piece = this.pieces[Move_1.default.get.to(move)];\r\n                if (Piece_1.default.get.type(piece) === type)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    allMoves(safe = false) {\r\n        let moves = [];\r\n        for (let x = 0; x < 8; x++) {\r\n            for (let y = 0; y < 8; y++) {\r\n                let pos = Pos(x, y);\r\n                let piece = this.pieces[pos];\r\n                if (Piece_1.default.get.color(piece) !== this.turn || Piece_1.default.get.type(piece) === Type_1.Type.Empty)\r\n                    continue;\r\n                let _moves = safe ? this.generateSafeMovesAt(pos) : this.generateMovesAt(pos);\r\n                for (let move of _moves)\r\n                    moves.push(move);\r\n            }\r\n        }\r\n        return moves;\r\n    }\r\n    inCheck(turn = this.turn) {\r\n        let pos = this.kingPos(turn);\r\n        return (pos === null) ? false : !this.isSafe(pos, turn);\r\n    }\r\n    inMate() {\r\n        return this.allMoves(true).length === 0;\r\n    }\r\n}\r\nexports.Engine = Engine;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bitfield_1 = __importDefault(require(\"./bitfield\"));\r\nexports.default = bitfield_1.default([\r\n    [\"to\", 6],\r\n    [\"from\", 6],\r\n    [\"captured\", 5],\r\n    [\"firstMove\", 1],\r\n    [\"promotion\", 1]\r\n]);\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bitfield_1 = __importDefault(require(\"./bitfield\"));\r\nlet s = bitfield_1.default([\r\n    [\"type\", 3],\r\n    [\"color\", 1],\r\n    [\"moved\", 1]\r\n]);\r\nexports.default = s;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bitfield_1 = __importDefault(require(\"./bitfield\"));\r\nlet s = bitfield_1.default([\r\n    [\"x\", 3],\r\n    [\"y\", 3]\r\n]);\r\nexports.default = s;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Type;\r\n(function (Type) {\r\n    Type[Type[\"Empty\"] = 0] = \"Empty\";\r\n    Type[Type[\"Pawn\"] = 1] = \"Pawn\";\r\n    Type[Type[\"Knight\"] = 2] = \"Knight\";\r\n    Type[Type[\"Bishop\"] = 3] = \"Bishop\";\r\n    Type[Type[\"Rook\"] = 4] = \"Rook\";\r\n    Type[Type[\"Queen\"] = 5] = \"Queen\";\r\n    Type[Type[\"King\"] = 6] = \"King\";\r\n})(Type = exports.Type || (exports.Type = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst mask = (width) => (1 << width) - 1;\r\nfunction propertiesWithShift(properties) {\r\n    let shift = 0;\r\n    let result = [];\r\n    for (let [name, width] of properties) {\r\n        result.push([name, width, shift]);\r\n        shift += width;\r\n    }\r\n    return result;\r\n}\r\nfunction fromArguments(properties) {\r\n    let names = properties.map((component) => component[0]);\r\n    let parts = properties.map(([name, width, shift]) => `(${name} << ${shift})`);\r\n    let result = new Function(...names, \"return \" + parts.join(\" | \"));\r\n    return result;\r\n}\r\nfunction fromObject(properties) {\r\n    let parts = properties.map(([name, width, shift]) => `(object.${name} << ${shift})`);\r\n    let result = new Function(\"object\", \"return \" + parts.join(\" | \"));\r\n    return result;\r\n}\r\nfunction toObject(properties) {\r\n    let parts = properties.map(([name, width, shift]) => `${name}: (struct >> ${shift}) & ${mask(width)}`);\r\n    let result = new Function(\"struct\", `return { ${parts.join(\" , \")} }`);\r\n    return result;\r\n}\r\nfunction struct(properties) {\r\n    let bitCount = properties.map((component) => component[1]).reduce((x, y) => x + y);\r\n    if (bitCount > 32)\r\n        throw new Error(\"Components don't fit 32 bit number.\");\r\n    let _properties = propertiesWithShift(properties);\r\n    let get = {};\r\n    let set = {};\r\n    for (let [name, width, shift] of _properties) {\r\n        let getMask = mask(width);\r\n        get[name] = (struct) => (struct >> shift) & getMask;\r\n        let setMask = ~(getMask << shift); // Used to clear components bits.\r\n        set[name] = (struct, value) => (struct & setMask) | ((value & getMask) << shift);\r\n    }\r\n    return { create: fromArguments(_properties), toObject: toObject(_properties), fromObject: fromObject(_properties), get, set };\r\n}\r\nexports.default = struct;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Color_1 = require(\"./Color\");\r\nconst Piece_1 = __importDefault(require(\"./Piece\"));\r\nconst pieceToCharStr = \".pnbrqk\";\r\nfunction pieceToChar(piece) {\r\n    let char = pieceToCharStr[Piece_1.default.get.type(piece)];\r\n    return Piece_1.default.get.color(piece) === Color_1.Color.Black ? char : char.toUpperCase();\r\n}\r\nexports.pieceToChar = pieceToChar;\r\nfunction charToPiece(char) {\r\n    let type = pieceToCharStr.indexOf(char.toLowerCase());\r\n    let color = (char === char.toLowerCase()) ? Color_1.Color.Black : Color_1.Color.White;\r\n    return Piece_1.default.create(type, color, 0);\r\n}\r\nexports.charToPiece = charToPiece;\r\nexports.default = { pieceToChar, charToPiece };\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = [\r\n    0,\r\n    1,\r\n    3,\r\n    3,\r\n    5,\r\n    9,\r\n    99999 // King\r\n];\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Position_1 = __importDefault(require(\"./Position\"));\r\nconst Piece_1 = __importDefault(require(\"./Piece\"));\r\nconst Move_1 = __importDefault(require(\"./Move\"));\r\nconst pieceValues_1 = __importDefault(require(\"./pieceValues\"));\r\nconst Type_1 = require(\"./Type\");\r\nconst Color_1 = require(\"./Color\");\r\nconst Pos = Position_1.default.create;\r\nconst MAX_VALUE = Number.MAX_SAFE_INTEGER; // Infinity\r\nfunction default_1(engine, options = {}) {\r\n    options = Object.assign({ depth: 40, rootCall: true, maxSeconds: 5 }, options);\r\n    let startTime = Date.now();\r\n    let endTime = startTime + options.maxSeconds * 1000;\r\n    let evaluations = 0;\r\n    let cache = options.cache || new Map();\r\n    const heuristic = (useFast) => {\r\n        evaluations++;\r\n        const config = {\r\n            material: 10,\r\n            control: 5,\r\n            threat: 1,\r\n            threateningPieces: 1,\r\n            development: 5,\r\n            support: 5\r\n        };\r\n        if (engine.inCheck() && engine.inMate())\r\n            return engine.turn == Color_1.Color.White ? -MAX_VALUE : MAX_VALUE;\r\n        if (useFast)\r\n            return engine.netMaterialValue * config.material;\r\n        if (engine.inMate())\r\n            return 0;\r\n        let control = 0;\r\n        let threat = 0;\r\n        let threateningPieces = 0;\r\n        let development = 0;\r\n        let support = 0;\r\n        const edgeDistance = (pos) => {\r\n            let xDist = 3.5 - Math.abs(Position_1.default.get.x(pos) - 3.5);\r\n            let yDist = 3.5 - Math.abs(Position_1.default.get.y(pos) - 3.5);\r\n            return xDist + yDist;\r\n        };\r\n        for (let pos = 0; pos < 64; pos++) {\r\n            let piece = engine.pieces[pos];\r\n            let type = Piece_1.default.get.type(piece);\r\n            if (type === Type_1.Type.Empty)\r\n                continue;\r\n            let invPieceValue = 1 / pieceValues_1.default[type];\r\n            let color = Piece_1.default.get.color(piece);\r\n            let valueSign = color === Color_1.Color.White ? 1 : -1;\r\n            development += edgeDistance(pos) * invPieceValue * valueSign;\r\n            if (type === Type_1.Type.Pawn) {\r\n                let pawnDevelopment = (color == Color_1.Color.White) ? 7 - Position_1.default.get.y(pos) : Position_1.default.get.y(pos);\r\n                development += Math.max(8, 1.5 ** pawnDevelopment) * valueSign;\r\n            }\r\n            let threatening = false;\r\n            for (let move of engine.generateMovesAt(pos, true)) {\r\n                let capturedType = Piece_1.default.get.type(Move_1.default.get.captured(move));\r\n                let capturedColor = Piece_1.default.get.color(Move_1.default.get.captured(move));\r\n                let captured = capturedType !== Type_1.Type.Empty;\r\n                if (captured && capturedColor == color) {\r\n                    support += valueSign * invPieceValue / pieceValues_1.default[capturedType];\r\n                }\r\n                else {\r\n                    let to = Move_1.default.get.to(move);\r\n                    control += (1 + edgeDistance(to) * invPieceValue) * valueSign;\r\n                    if (captured) {\r\n                        threatening = true;\r\n                        let value = capturedType == Type_1.Type.King ? 10 : pieceValues_1.default[capturedType] * invPieceValue;\r\n                        threat += valueSign * value;\r\n                    }\r\n                }\r\n            }\r\n            if (threatening)\r\n                threateningPieces += valueSign;\r\n        }\r\n        return engine.netMaterialValue * config.material\r\n            + control * config.control\r\n            + threat * config.threat\r\n            + threateningPieces * config.threateningPieces\r\n            + development * config.development\r\n            + support * config.support;\r\n    };\r\n    const search = (depth = 0, rootCall = true, alpha = options.alpha || -MAX_VALUE, beta = options.beta || MAX_VALUE) => {\r\n        let turn = engine.turn;\r\n        let valueSign = (engine.turn === Color_1.Color.White) ? 1 : -1;\r\n        let positionString = engine.positionString() + depth + \",\" + turn;\r\n        if (!rootCall && cache.has(positionString))\r\n            return cache.get(positionString);\r\n        let pairs = engine.allMoves(true).map((move) => {\r\n            engine.doMove(move);\r\n            let h = heuristic(depth < 3);\r\n            engine.undoMove();\r\n            return [move, h];\r\n        });\r\n        pairs.sort((a, b) => ((b[1] - a[1]) * valueSign));\r\n        let best = null;\r\n        let bestValue = -MAX_VALUE * valueSign;\r\n        let cutoff = false;\r\n        for (let [move, h] of pairs) {\r\n            if (Date.now() > endTime)\r\n                break;\r\n            let value = 0;\r\n            engine.doMove(move);\r\n            value = depth == 1 ? h : search(depth - 1, false, alpha, beta);\r\n            // The advanced heuristic is too slow to use on leaves so instead it's evaluated on the parent.\r\n            if (depth == 3)\r\n                value += heuristic(false);\r\n            if (best === null || value * valueSign > bestValue * valueSign) {\r\n                best = move;\r\n                bestValue = value;\r\n                if (turn === Color_1.Color.White)\r\n                    alpha = Math.max(alpha, bestValue);\r\n                else\r\n                    beta = Math.min(beta, bestValue);\r\n                cutoff = (alpha >= beta);\r\n            }\r\n            engine.undoMove();\r\n            if (cutoff)\r\n                break;\r\n        }\r\n        cache.set(positionString, bestValue);\r\n        return rootCall ? [best, bestValue] : bestValue;\r\n    };\r\n    let result, resultValue, depthReached;\r\n    for (let d = 3; d <= options.depth; d++) {\r\n        let _ = search(d);\r\n        if (Date.now() > endTime)\r\n            break;\r\n        [result, resultValue] = _;\r\n        depthReached = d;\r\n    }\r\n    if (options.rootCall) {\r\n        let dt = (Date.now() - startTime);\r\n        let addCommas = (x) => x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n        let evalsPerMs = (evaluations / dt).toString().split(\".\")[0];\r\n        console.log(`${addCommas(evaluations)} evals | ${addCommas(dt)} ms | ${addCommas(evalsPerMs)} evals/ms | depth ${depthReached} reached`);\r\n    }\r\n    return options.rootCall ? result : resultValue;\r\n}\r\nexports.default = default_1;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst search_1 = __importDefault(require(\"../../engine/search\"));\r\nconst Engine_1 = require(\"../../engine/Engine\");\r\nasync function default_1(req, res) {\r\n    let { position } = req.body;\r\n    let engine = Engine_1.Engine.fromString(position);\r\n    let move = search_1.default(engine, { depth: 6 });\r\n    // let move = await parallelSearch(position)\r\n    res.type(\"text/json\").send(JSON.stringify(move));\r\n}\r\nexports.default = default_1;\r\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}